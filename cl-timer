#!/usr/bin/env python3

import json
from os.path import dirname, isfile
from pathlib import Path
import string
import subprocess
import sys
import random
import curses
from os import mkdir
import signal
import time


DECIMAL_POINT = ' \n \n.\n '


DIGITS = [
    ' __ \n|  |\n|__|\n    ',
    '    \n|   \n|   \n    ',
    ' __ \n __|\n|__ \n    ',
    ' __ \n __|\n __|\n    ',
    '    \n|__|\n   |\n    ',
    ' __ \n|__ \n __|\n    ',
    ' __ \n|__ \n|__|\n    ',
    ' __ \n|  |\n   |\n    ',
    ' __ \n|__|\n|__|\n    ',
    ' __ \n|__|\n   |\n    ',
]


DISCLAIMER = '\
The timer starts a few moments after you let go of the spacebar,\nbut immedia\
tely afterwards it catches up to the correct times.\n\nKnow that the time disp\
layed at the end to each solve is accurate\ndown to the hundredth of a second,\
 as are all of the other stats\nmade available by this timer.\n\nThanks for re\
ading, and have fun!'



STARTING_TIME = ' __     __   __\n|  |   |  | |  |\n|__| . |__| |__|'


STATS = '\
STATS FOR SOLVE %s\n\nTime: %s\nAverage of 5: %s\nAverage of 12: %s\nScramble:\
 %s\n\n\nPress any key to exit'



TIMER_BACKGROUND = '\
------------------------------------------------\n|                          \
                    |\n|                                              |\n|    \
                                          |\n|                                \
              |\n|                                              |\n|          \
                                    |\n---------------------------------------\
---------'


TITLE_ART = '\
              #  #  #  #\n        # #      |      .  .\n      #          |    \
      .\n     #           |           .\n     #           |           .\n    #\
            |            .\n    #            .-------     .\n    #            \
             .    Timer\n    #                         .\n     #              \
         .\n     #                       .\n      #                     .\n   \
     # #            .  .\n            #  #  #  # \n\n\npress any key to contin\
ue\n'

class Canvas:
    """
    The current state of the screen.

    Constantly being edited by existence and change of Image objects.
    """

    def __init__(self, height, width):
        # List of rows. Top row when displayed is at index 0
        self.grid = [[' ' for _ in range(width)] for _ in range(height)]

    def replace(self, x, y, char):
        """
        Replaces char in certain location of self.grid
        """
        row_index = (len(self.grid) - 1) - y
        try:
            self.grid[row_index][x] = char
        except IndexError:
            pass

    @property
    def display(self):
        """
        String that is displayed onto the screen
        """
        rows = [''.join(row) for row in self.grid][::-1]
        return '\n'.join(rows)


class Char:
    """
    A single character that is part of an Image
    """

    def __init__(self, x, y, char):

        self.x = x
        self.y = y
        if len(char) == 1:
            self.char = char
        else:
            raise ValueError('Char object can only represent one char.')

    def change_coords(self, x, y):
        """
        Changes self.x and self.y to `x` and `y`
        """
        self.x = x
        self.y = y

    @classmethod
    def fromstring(cls, string):
        """
        Takes string and returns array of Char objects
        that can be used to create and Image object that appears as that string.
        """
        chars = []
        for y, line in enumerate(string.split('\n')):
            for x, char in enumerate(line):
                chars.append(Char(x, y, char))
        return chars


class Image:
    """
    Something that alters the appearance of a Canvas object.
    """

    def __init__(self, canvas, x, y, chars):
        
        self.canvas = canvas
        self.x = x
        self.y = y
        self.chars = chars

    @property
    def displayed_chars(self):
        return self.chars

    @displayed_chars.setter
    def displayed_chars(self, chars):
        for char in self.chars:
            self.canvas.replace(char.x + self.x, char.y + self.y, " ")
        self.chars = chars

    def render(self):
        """
        Alter canvas display to update current state of self.
        """
        
        for char in self.chars:
            
            canvas_x = self.x + char.x
            canvas_y = self.y + char.y

            self.canvas.replace(canvas_x, canvas_y, char.char)

    def __str__(self):
        """
        Shows what image is supposed to render on the canvas like.

        Mainly for debugging purposes.
        """

        max_x = max([char.x for char in self.chars]) + 1
        max_y = max([char.y for char in self.chars]) + 1

        chars = [[[] for _ in range(max_x)] for _ in range(max_y)]

        for char in self.chars:
            chars[char.y][char.x] = char.char

        for i, l in enumerate(chars[:]):
            if [] in l:
                for k in range(l.count([])):
                    chars[i].remove([])

        return '\n'.join([''.join(line) for line in chars])


class InputLine(Image):
    """
    Represents a line where if you type, it will record what was typed
    """

    def __init__(self, canvas, prompt):

        # prompt never stored as attribute because it is never used except now.

        self.prompt = prompt
        self.prompt_length = len(self.prompt)
        self.cursor_index = self.prompt_length
        self.submitted = False
        self.inputted_chars = []

        y = len(canvas.grid) - 1
        prompt_chars = [Char(i, 0, char) for i, char in enumerate(self.prompt)]
        # this Image fills entire horizontal distance of canvas
        input_chars = [Char(i, 0, ' ') for i in range(self.prompt_length, len(canvas.grid[-1]))]
        chars = prompt_chars + input_chars

        Image.__init__(self, canvas, 0, y, chars)

    @property
    def value(self):
        """
        The text that has been inputted up to this point
        """
        return ''.join(self.inputted_chars)

    def _del_char(self):
        """
        Removes last char from input field
        """
        if self.cursor_index > self.prompt_length:
            # change value
            self.inputted_chars.pop(self.cursor_index - self.prompt_length - 1)

            # change appearance
            self.chars = Char.fromstring(
                self.prompt + ''.join(self.inputted_chars) + ''.join(
                    [' ' for _ in range(len(self.canvas.grid[-1]) - (self.prompt_length + len(self.inputted_chars)))]))

            self.cursor_index -= 1

    def type_char(self, char):
        """
        Adds char to value of input field
        """

        # -1 - no key pressed
        # 127 - backspace
        # 10 - enter
        # 260 - left arrow
        # 261 - right arrow
        if not (char in [-1, 127, 10, 260, 261]):
            new_char = chr(char)  # converts int ascii code to get string for inputted char

            # replace current char in cursor location with new char
            self.inputted_chars.insert(self.cursor_index - self.prompt_length, new_char)
            self.cursor_index += 1

            self.chars = Char.fromstring(
                self.prompt + ''.join(self.inputted_chars) + ''.join(
                    [' ' for _ in range(len(self.canvas.grid[-1]) - (self.prompt_length + len(self.inputted_chars)))]))

        elif char == 127:  # backspace
            self._del_char()

        elif char == 10:  # enter
            self.submitted = True

            # renders self as a line of space chars, appearing invisible.
            self.chars = [Char(i, 0, ' ') for i in range(len(self.chars))]
            self.render()
        
        elif char == 260:
            if (self.cursor_index - self.prompt_length - 1) >= 0:
                self.cursor_index -= 1
        
        elif char == 261:
            if (self.prompt_length + len(self.inputted_chars)) >= (self.cursor_index + 1):
                self.cursor_index += 1


class CommandInput(InputLine):
    """
    Represents an InputLine that is meant for typing commands

    Like vim, it is triggered by pressing ':'.
    Commands typed here will return info about the session.
    """

    def __init__(self, canvas):
        InputLine.__init__(self, canvas, ': ')

    def hide(self):
        for char in self.chars:
            self.canvas.replace(self.x + char.x, self.y + char.y, " ")


class NumberDisplay(Image):
    """
    The Image that shows the time
    """
    def __init__(self, canvas, x, y):
        self.digit_char_arrays = []
        self.time = 0
        self.digits = []
        self.chars = Char.fromstring(STARTING_TIME)
        Image.__init__(self, canvas, x, y, self.chars)

    def update(self):
        """
        This is to differentiate from the increment method
        so it can be executed separately.
        (The code in this functino was formerly in the increment method)
        """
        len_digits = len(self.digits)
        self.digits = [int(d) if d != '.' else d for d in 
                       str(round(self.time, 2))]

        if len(self.digits[self.digits.index('.') + 1:]) != 2:
            self.digits.append(0)

        digit_strings = []
        for digit in self.digits:
            if digit != '.':
                digit_strings.append(DIGITS[digit])
            else:
                digit_strings.append(DECIMAL_POINT)


        full_string_lines = [[] for i in range(4)]
        for i in range(4):
            for digit_string in digit_strings:
                full_string_lines[i].append(digit_string.split('\n')[i])
        full_string = '\n'.join([' '.join(line) for line in full_string_lines])

        self.chars = Char.fromstring(full_string)

    def reset(self):
        self.time = 0
        self.chars = Char.fromstring(STARTING_TIME)


class CoverUpImage(Image):
    """
    An image that covers up it's previous characters when it's chars are changed
    """

    def __init__(self, canvas, x, y, chars):
        
        self.canvas = canvas
        self.x = x
        self.y = y
        self._chars = chars

    @property
    def chars(self):
        return self._chars

    @chars.setter
    def chars(self, chars):
        for c in self._chars:
            self.canvas.replace(self.x + c.x, self.y, " ")
        self._chars = chars
        self.render()


def break_top_line(string, line_length):
    """
    Takes a string containing a scramble and returns a string that is the same
    as the first string but with a newline in there that doesn't break any
    moves but also makes the length of the new first line less than the `line_length`
    """
    moves = string.split(' ')
    substrings = [' ' for _ in range(len(moves) - 1)]  # moves or spaces
    for i, move in enumerate(moves):
        substrings.insert(i * 2, move)
    lengths = [len(substring) for substring in substrings]
    
    newline_index = 0

    previous_sum = 0
    for i in range(len(lengths)):
        slice_sum = sum(lengths[:i])
        if line_length == slice_sum:
            newline_index = slice_sum
            break
        if (line_length < slice_sum) and (line_length > previous_sum):
            newline_index = previous_sum
            break
        previous_sum = slice_sum
    
    chars = list(string)
    chars.insert(newline_index, '\n')
    return ''.join(chars)


class Scramble(CoverUpImage):
    """
    Optimized for showing a scramble
    """

    def __init__(self, canvas, x, y, chars):
        CoverUpImage.__init__(self, canvas, x, y, chars)

    def clear(self):
        """
        Replaces all chars on canvas with spaces
        """
        ys = []
        for x, y in ([(c.x, c.y) for c in self._chars]):
            self.canvas.replace(self.x + x, self.y + y, " ")
            if y not in ys:
                ys.append(y)

    def render(self):
        """
        This exists because scrambles can be longer than the length of the screen
        """
        if len(self._chars) > len(self.canvas.grid[0]):
            lines = []
            bottom_line = str(self)
            while True:
                scramble_with_newline = break_top_line(bottom_line, len(self.canvas.grid[0]) - 1)
                lines.append(scramble_with_newline.split('\n')[0])
                new_bottom_line = scramble_with_newline.split('\n')[1]
                if new_bottom_line == bottom_line:
                    break
                bottom_line = new_bottom_line
            self._chars = Char.fromstring('\n'.join([l.strip() for l in lines]))
            Image.render(self)
        else:
            Image.render(self)


class Cursor(Image):
    """
    Represents the block character used to represent cursor
    """

    def __init__(self, canvas):

        # u'\u2588' is the unicode full-block character

        Image.__init__(self, canvas, 0, 0, [Char(0, 0, u'\u2588')])

        self.previous_x = self.x
        self.previous_y = self.y

        # self.potential_chars = [Char(0, 0, self.canvas.grid[(len(self.grid) - 1) - self.y][self.x]), u'\u2588']

        # self.previous_char = [self.potential_chars[0]]

        self.previous_char = Char(0, 0, ' ')

    def render(self):
        """
        Override inherited render method because
        this Image can move and has only one char
        """

        # cover previous location
        self.canvas.replace(
            self.previous_y,
            (len(self.canvas.grid) - 1) - self.previous_x,
            ' ')

        # show self in current location
        self.canvas.replace(
            self.y,
            (len(self.canvas.grid) - 1) - self.x,
            self.chars[0].char)

    def toggle_char(self):
        """
        Changes from block char to space for blinking effect
        """
        new_char = self.previous_char
        old_char = self.chars[0]
        self.chars[0] = new_char
        self.previous_char = old_char

    def move(self, x, y):
        """
        Moves cursor to (x, y) on the canvas
        """

        self.previous_x = self.x
        self.previous_y = self.y

        self.x = x
        self.y = y

    def hide(self):
        """
        Temporarily hides self.
        """

        self.chars[0] = Char(0, 0, ' ')
        self.render()

HOME = str(Path.home())

char = lambda string: Char.fromstring(string)


def command_line(
        canvas, stdscr, settings, scramble_image, settings_file, session_file,
        times, ao5s, ao12s, scrambles, session, session_name_image, update_stats,
        add_time, calculate_average, aliases, silent=False, command=False):
    """
    Inspired by vim...
    """

    def delete(solve):
        """
        Removes all records of solve at index `solve`
        """
        # remove from lists of data
        times.pop(solve - 1)
        ao5s.pop(solve - 1)
        ao12s.pop(solve - 1)
        scrambles.pop(solve - 1)

        # remove from session file
        with open(session_file.string, 'r') as f:
            lines = f.read().split('\n')
        lines.pop(solve - 1)
        with open(session_file.string, 'w') as f:
            f.write('\n'.join(lines))

    def dnf():
        """
        Flags latest solve as DNF
        """
        # update `times`
        solve_time = times[-1]
        times[-1] = f'DNF({solve_time})'
        ao5s[-1] = calculate_average(len(ao5s), 5)
        ao12s[-1] = calculate_average(len(ao12s), 12)

        # update session file
        with open(session_file.string, 'r') as f:
            lines = [line.split('\t') for line in f.read().split('\n')]
        if [''] in lines:
            lines.remove([''])
        lines[-1][0] = f'DNF({solve_time})'
        with open(session_file.string, 'w') as f:
            f.write('\n'.join(['\t'.join(line) for line in lines]))

    def plus_two():
        """
        Adds two to the value of the latest solves,
        while also marking it as a plus two
        """
        # udpate `times`
        solve_time = times[-1]
        times[-1] = add_zero(round(float(solve_time) + 2, 2)) + '+'
        ao5s[-1] = calculate_average(len(ao5s), 5)
        ao12s[-1] = calculate_average(len(ao12s), 12)

        # update session file
        with open(session_file.string, 'r') as f:
            lines = [line.split('\t') for line in f.read().split('\n')]
        if [''] in lines:
            lines.remove([''])
        lines[-1][0] = add_zero(round(float(solve_time) + 2, 2)) + '+'
        with open(session_file.string, 'w') as f:
            f.write('\n'.join(['\t'.join(line) for line in lines]))

    def show_error_message(string):
        if not silent:
            Image(canvas, 0, len(canvas.grid) - 1, char(string)).render()
        raise CommandSyntaxError

    def interpret(command):
        """
        Performs tasks according to what the command tells it
        """

        if ';' in command:
            for subcommand in command.split(';'):
                interpret(subcommand.strip())
            return

        if command.count('"') % 2 != 0:
            show_error_message('syntax error: odd number of quotes (")')

        if '  ' in command:
            show_error_message('syntax error: command parts separated by more than one space ( )')
        
        words = []
        current_chars = []
        in_quotes = False
        skip = False
        for i, c in enumerate(command):

            if skip:
                skip = False
                continue

            if in_quotes:
                if c == '"':
                    in_quotes = False
                    skip = True
                    words.append(''.join(current_chars))
                    current_chars.clear()
                else:
                    current_chars.append(c)
            else:
                if c == '"':
                    in_quotes = True
                elif c == ' ':
                    words.append(''.join(current_chars))
                    current_chars.clear()
                else:
                    current_chars.append(c)

        if command[-1] != '"':
            words.append(command.split(' ')[-1])

        if words[0] == 'alias':
            if len(words) != 3:
                show_error_message(f'`alias` takes exactly 2 arguments - {len(words) - 1} were given')
            
            if words[1] in ['s', 'i', 'c', 'rm', 'd', 'p', 'q', 'a', 'alias']:
                show_error_message(f'{words[1]} is a command. Choose a different name.')
            
            aliases[words[1]] = words[2].strip()

        elif words[0] == 's':
            
            if len(words) != 3:
                if len(words) == 1:
                    show_error_message('`s` takes exactly 2 arguments - 0 were given')
                else:
                    if words[1] in ['p', 'sl']:
                        show_error_message(f'`s {words[1]}` takes 1 argument - {len(words) - 2} were given')
            
            if words[1] in ['p', 'sl']:
                if words[1] == 'p':
                    try:
                        if not (int(words[2]) in [i for i in range(2, 8)]):
                            show_error_message('`s p` takes an integer between 2 and 7 (inclusive) as an argument')
                    except ValueError:
                        show_error_message('`s p` takes an integer between 2 and 7 (inclusive) as an argument')
                if words[1] == 'sl':
                    try:
                        int(words[2])
                    except ValueError:
                        show_error_message(f'invalid integer value: {words[2]}')
            else:
                show_error_message(f'`s` - invalid argument: "{words[1]}"')

            if words[1] == 'sl':
                settings['scramble-length'] = words[2]
            elif words[1] == 'p':
                settings['puzzle'] = words[2]

            new_scramble = generate_scramble(int(settings['puzzle']),
                                            int(settings['scramble-length']))
            scramble_image.clear()
            scramble_image.chars = char(new_scramble)

            with open(settings_file.string, 'w') as f:
                json.dump(settings, f)
                
        elif words[0] == 'i':
            if len(words) == 1:
                subprocess.call(['vim', session_file.string])
            elif len(words) == 2:
                try:
                    if not (int(words[1]) in range(1, len(times) + 1)):
                        show_error_message(f'invalid integer value: `{int(words[1])}`')
                except ValueError:
                    show_error_message('`i` takes an integer as an argument')
                display_stats(stdscr, int(words[1]), times, ao5s, ao12s, scrambles)
            else:
                show_error_message(f'`i` takes either 0 or 1 argument(s) - {len(words) - 1} were given')

        elif words[0] == 'c':

            if len(words) != 2:
                show_error_message(f'`c` takes exactly 1 argument - {len(words) - 1} were given')

            for c in words[1]:
                if c not in string.printable[:-5]:
                    show_error_message(f'invalid file name: {words[1]}')
            new_file = False
            session.string = words[1]
            session_file.string = f"{HOME}/.cl-timer/{words[1]}"
            settings_file.string = f"{HOME}/.cl-timer/{words[1]}-settings.json"
            session_name_image.displayed_chars = char(words[1])
            session_name_image.render()
            
            s = len(times)

            for lst in [times, ao5s, ao12s, scrambles]:
                for _ in range(s):
                    lst.pop(0)

            if not isfile(session_file.string):
                with open(session_file.string, 'w+') as f:
                    pass
            else:
                with open(session_file.string, 'r') as f:
                    time_lines = [line.split('\t') for line in f.read().split('\n')]

                for line in time_lines:
                    times.append(line[0])
                    ao5s.append(line[1])
                    ao12s.append(line[2])
                    scrambles.append(line[3])
        
            if isfile(settings_file.string):
                with open(settings_file.string, 'r') as f:
                    for key, value in json.load(f).items():
                        settings[key] = value
            else:
                settings['puzzle'] = '3'
                settings['scramble-length'] = '20'
                with open(settings_file.string, 'w+') as f:
                    json.dump(settings, f)

            update_stats()
        
        elif words[0] == 'rm':

            if len(words) != 2:
                show_error_message(f'`rm` takes exactly 1 argument - {len(words) - 1} were given')

            try:
                if int(words[1]) not in range(1, len(times) + 1):
                    show_error_message(f'invalid integer value: {words[1]}')
            except ValueError:
                if words[1] == 'all':
                    ip = InputLine(canvas, "Are you sure you want to delete all the times in this session? (y/n) ")
                    answer = ask_for_input(
                        stdscr, canvas, ip, Cursor(canvas), True)
                    if answer == 'y':
                        for _ in range(1, len(times[:]) + 1):
                            delete(1)
                        update_stats()
                        return
                    else:
                        return
                else:
                    show_error_message(f'invalid integer value: {words[1]}')

            delete(int(words[1]))

            for i in range(len(ao5s)):
                ao5s[i] = calculate_average(i + 1, 5)
            for i in range(len(ao12s)):
                ao12s[i] = calculate_average(i + 1, 12)

            with open(session_file.string, 'w') as f:
                f.write(
                    '\n'.join(
                        ['\t'.join([str(thing) for thing in 
                            [time, ao5, ao12, scramble]])
                            for time, ao5, ao12, scramble in
                            zip(times, ao5s, ao12s, scrambles)]
                        )
                    )

            update_stats()
            
        elif words[0] == 'd':

            if len(words) != 1:
                show_error_message(f'`d` takes exactly 0 arguements - {len(words) - 1} were given')

            dnf()
            update_stats()        

        elif words[0] == 'p':

            if len(words) != 1:
                show_error_message(f'`p` takes exactly 0 arguements - {len(words) - 1} were given')

            plus_two()
            update_stats()
            
        elif words[0] == 'q':

            if len(words) != 1:
                show_error_message(f'`q` takes exactly 0 arguements - {len(words) - 1} were given')

            raise ExitException()

        elif words[0] == 'a':

            if len(words) != 2:
                show_error_message(f'`a` takes exactly 1 arguement - {len(words) - 1} were given')

            try:
                add_time(float(words[1]))
            except ValueError:
                show_error_message(f'invalid time: {words[1]}')

        elif words[0] in aliases.keys():
            interpret(aliases[words[0]] + f' {" ".join(words[1:])}')

        else:  # command was not recognized
            show_error_message(f'{words[0]}: Invalid command')

    if not command:
        Image(canvas, 0, 0, char(canvas.display))
        command_inputs = []

        while True:
            try:
                cmd_ipt = CommandInput(canvas)
                command_inputs.append(cmd_ipt)
                cmd = ask_for_input(
                    stdscr, canvas, cmd_ipt, Cursor(canvas), True).strip()
            except ExitCommandLine:
                for c in command_inputs:
                    c.hide()
                return
            interpret(cmd)
    else:
        interpret(command)

def groups(lst, division):
    if isinstance(division, int):
        return [lst[i:i + division] for i in range(0, len(lst), division)]
    elif isinstance(division, list):
        i = 0
        new_lst = []
        for k in division:
            new_lst.append(lst[i:i + k])
            i += k
        return new_lst


MOVES = [
    ['R', "R'", 'R2',  # 2x2
     'U', "U'", 'U2',  #
     'F', "F'", "F2"], #
    ['R', "R'", 'R2', 'L', "L'", 'L2',  # 3x3
     'U', "U'", 'U2', 'D', "D'", 'D2',  #
     'F', "F'", 'F2', 'B', "B'", 'B2'], #
    ['R', "R'", 'R2', 'Rw', "Rw'", 'Rw2', 'L', "L'", 'L2',  # 4x4
     'U', "U'", 'U2', 'Uw', "Uw'", 'Uw2', 'D', "D'", 'D2',  #
     'F', "F'", 'F2', 'Fw', "Fw'", 'Fw2', 'B', "B'", 'B2'], #
    ['R', "R'", 'R2', 'Rw', "Rw'", 'Rw2', 'L', "L'", 'L2', 'Lw', "Lw'", 'Lw2',  # 5x5
     'U', "U'", 'U2', 'Uw', "Uw'", 'Uw2', 'D', "D'", 'D2', 'Dw', "Dw'", 'Dw2',  #
     'F', "F'", 'F2', 'Fw', "Fw'", 'Fw2', 'B', "B'", 'B2', 'Bw', "Bw'", 'Bw2'], #
    ['R', "R'", 'R2', 'Rw', "Rw'", 'Rw2', '3Rw', "3Rw'", '3Rw2', 'L', "L'", 'L2', 'Lw', "Lw'", 'Lw2',  # 6x6
     'U', "U'", 'U2', 'Uw', "Uw'", 'Uw2', '3Uw', "3Uw'", '3Uw2', 'D', "D'", 'D2', 'Dw', "Dw'", 'Dw2',  #
     'F', "F'", 'F2', 'Fw', "Fw'", 'Fw2', '3Fw', "3Fw'", '3Fw2', 'B', "B'", 'B2', 'Bw', "Bw'", 'Bw2'], #
    ['R', "R'", 'R2', 'Rw', "Rw'", 'Rw2', '3Rw', "3Rw'", '3Rw2', 'L', "L'", 'L2', 'Lw', "Lw'", 'Lw2', '3Lw', "3Lw'", '3Lw2',  # 7x7
     'U', "U'", 'U2', 'Uw', "Uw'", 'Uw2', '3Uw', "3Uw'", '3Uw2', 'D', "D'", 'D2', 'Dw', "Dw'", 'Dw2', '3Dw', "3Dw'", '3Dw2',  #
     'F', "F'", 'F2', 'Fw', "Fw'", 'Fw2', '3Fw', "3Fw'", '3Fw2', 'B', "B'", 'B2', 'Bw', "Bw'", 'Bw2', '3Bw', "3Bw'", '3Bw2']  #
    ]

AXES = [groups(lst, (i + 1) * 3) for i, lst in enumerate(MOVES)]

SIDE_LENTHS = [
    [3 for _ in range(3)],  # 2x2
    [3 for _ in range(6)],  # 3x3
    [6 if i % 2 == 0 else 3 for i in range(6)],  # 4x4
    [6 for _ in range(6)],  # 5x5
    [9 if i % 2 == 0 else 6 for i in range(6)],  # 6x6
    [9 for _ in range(6)]
]

SIDES = [groups(lst, side_lengths) for side_lengths, lst in zip(SIDE_LENTHS, MOVES)]


def choose_move(scramble_moves, size):
    """
    Looks for a move that won't be redundant.

    Takes `scramble_moves` as the list of already listed moves.

    Chooses a random move.

    Since the last move of a different axis,
    if there has been a turn of the same side, 
    this move is redundant.

    If that is the case, it calls itself again
    until it finds a move that isn't redundant.
    """

    move = random.choice(MOVES[size - 2])
    axis = [axis for axis in AXES[size - 2] if move in axis][0]
    side = [side for side in SIDES[size - 2] if move in side][0]

    try:
        last_move_of_different_axis = [i for i, move in enumerate(scramble_moves)
                                       if move not in axis][-1]
    except IndexError:
        # there has only been moves of the same axis so far.
        last_move_of_different_axis = -1

    moves_since_then = scramble_moves[last_move_of_different_axis + 1:]
    if [move for move in moves_since_then if move in side] != []:
        return choose_move(scramble_moves, size)
    return move


def generate_scramble(size, length):
    """
    Returns a list of random moves 
    to scramble a rubik's cube in WCA notation
    """
    scramble_moves = []
    for i in range(length):
        scramble_moves.append(choose_move(scramble_moves, size))
    return ' '.join(scramble_moves)

class MutableString:
    def __init__(self, string):
        self._string = string

    @property
    def string(self):
        return self._string

    @string.setter
    def string(self, new_string):
        self._string = new_string


class ExitException(Exception):
    """
    Tells the program when to exit
    """

class ExitCommandLine(Exception):
    pass


class CommandSyntaxError(Exception):
    pass


def add_zero(number):
    """
    Add a zero if the value doesn't have
    2 digits behind it's decimal point
    """
    if number == '':
        return ''
    else:
        list_number = list(str(number))
        if len(list_number[list_number.index('.') + 1:]) < 2:
            list_number.append('0')
        return ''.join(list_number)


def ask_for_input(stdscr, canvas, input_line, cursor, command_line=False):
    """
    Uses graphics.InputLine object to get input from user.
    """
    frame = 0
    while True:

        key = stdscr.getch()

        if command_line == True:
            if key == 27:  # escape
                raise ExitCommandLine()

        if not input_line.submitted:

            input_line.type_char(key)
            cursor.move(0, input_line.cursor_index)
            if frame % 50 == 0:
                cursor.toggle_char()

            input_line.render()
            cursor.render()

        else:
            cursor.hide()
            break

        stdscr.clear()
        stdscr.addstr(canvas.display)
        stdscr.refresh()

        frame += 1
        time.sleep(0.01)

    return input_line.value


def display_text(stdscr, string):
    """
    A simple loop that diplays text until key is pressed
    """

    while True:

        key = stdscr.getch()

        if key != -1:
            break

        stdscr.clear()
        stdscr.addstr(string)
        stdscr.refresh()

        time.sleep(0.01)


def display_stats(stdscr, solve, times, ao5s, ao12s, scrambles):
    """
    Displays to screen stats about the solve with index `solve` - 1
    """
    i = solve - 1
    string = STATS % (solve, times[i], ao5s[i], ao12s[i], scrambles[i])
    display_text(stdscr, string)

HOME = str(Path.home())

try:
    mkdir(f'{HOME}/.cl-timer')
except FileExistsError:
    pass

settings = {
    'puzzle': '3',
    'scramble-length': '20'
}

aliases = {}

char = lambda string: Char.fromstring(string)


def convert_to_float(lst, purpose):
    """
    Returns list of all float-convertable values of `lst`,
    along with length of new list
    """
    float_times = []
    len_times = 0
    for t in lst:
        if (str(t)[:3] != 'DNF') and (t != '') and (str(t)[-1] != '+'):
            float_times.append(float(t))
            len_times += 1
        elif str(t)[-1] == '+':
            if purpose == 'average':
                float_times.append(float(t[:-1]))
                len_times += 1
            elif purpose == 'single':
                float_times.append(t)
                len_times += 1
    return float_times, len_times


def mainloops(stdscr):
    """
    Includes all mainloops for the app.
    """
    def signal_handler(sig, frame):
        """
        What to do in case of KeyboardInterrupt

        Writes times to session file
        (saving file interaction to the end saves time during frames.)
        """
        raise ExitException()

    signal.signal(signal.SIGINT, signal_handler)

    try:
        curses.curs_set(0)  # hide cursor (I have my own)
    except Exception:
        pass
    stdscr.nodelay(True)  # makes stdscr.getch() non-blocking

    canvas = Canvas(curses.LINES - 1, curses.COLS - 1)
    cursor = Cursor(canvas)

    display_text(stdscr, TITLE_ART)

    # sessions are groups of solves, stored in files in ~/.cl-timer
    # if this is a new session, create a new file, if not, use an existing one.

    session_name_input = InputLine(canvas, 'session name: ')
    session = MutableString(ask_for_input(stdscr, canvas, session_name_input, cursor))
    
    times = []
    ao5s = []
    ao12s = []
    scrambles = []
    session_file = ""

    session_file = MutableString(f'{HOME}/.cl-timer/{session.string}')
    if not isfile(session_file.string):
        with open(session_file.string, 'w+') as f:
            pass
    
    with open(session_file.string, 'r') as f:
        time_lines = [line.split('\t') for line in f.read().split('\n')]

    if [''] in time_lines:
        time_lines.remove([''])

    for line in time_lines:
        times.append(line[0])
        ao5s.append(line[1])
        ao12s.append(line[2])
        scrambles.append(line[3])

    settings_file = MutableString(f'{session_file.string}-settings.json')
    if not isfile(settings_file.string):
        with open(settings_file.string, 'w+') as f:
            json.dump(settings, f)
    
    with open(settings_file.string, 'r') as f:
        for key, value in json.load(f).items():
            settings[key] = value

    display_text(stdscr, DISCLAIMER)

    def add_time(t):
        """
        Add new solve with time of `t`
        """

        times.append(t)

        # update number display to show real time
        number_display.time = t
        number_display.update()

        # generate new scramble and update scramble_image
        new_scramble = generate_scramble(int(settings['puzzle']),
                                    int(settings['scramble-length']))
        scrambles.append(new_scramble)
        scramble_image.clear()
        scramble_image.chars = char(new_scramble)

        ao5, ao12 = update_stats()

        with open(session_file.string, 'a') as f:
            if len(times) == 1:
                f.write(f'{add_zero(t)}\t{ao5}\t{ao12}\t{new_scramble}')
            else:
                f.write(f'\n{add_zero(t)}\t{ao5}\t{ao12}\t{new_scramble}')
        
    def calculate_average(solve, length):
        """
        Returns average of `length` during `solve`

        Looks through times list and finds last `length` solves before `solve`
        Excludes best and worst times, and returns average of the rest.
        """
        if len(times[:solve]) < length:
            # `length` solves haven't been done yet.
            return ''
        else:
            latest_average = times[solve - length:]  # list of last `length` solves
            latest_average, _ = convert_to_float(latest_average, "average")
            if len(latest_average) < (length - 1):
                return 'DNF'
            if len(latest_average) == length:
                latest_average.remove(max(latest_average))
            latest_average.remove(min(latest_average))

            # calculate average and add zero if it doesn't go to 100ths place.
            
            return add_zero(round(sum(latest_average) / len(latest_average), 2))

    def get_session_mean():
        """
        Returns mean of all solves in session
        """
        try:
            float_times, len_times = convert_to_float(times, 'average')
            return add_zero(round(sum(float_times) / len_times, 2))
        except ZeroDivisionError:
            return ""

    def get_best_average(length):
        """
        Returns best average of `length` in session
        """
        try:
            if length == 5:
                best = add_zero(min([i for i in ao5s if i != '']))
            elif length == 12:
                best = add_zero(min([i for i in ao12s if i != '']))
        except ValueError:
            return ""
        return best

    def get_best_time():
        try:
            converted_times, _ = convert_to_float(times, 'single')
            float_times = [float(t[:-1]) if isinstance(t, str) else t for t in converted_times]
            best = converted_times[float_times.index(min(float_times))]
            if isinstance(best, float):
                return add_zero(best)
        except ValueError as e:
            return ""
        return best

    def get_worst_time():
        try:
            converted_times, _ = convert_to_float(times, 'single')
            float_times = [float(t[:-1]) if isinstance(t, str) else t for t in converted_times]
            worst = converted_times[float_times.index(max(float_times))]
            if isinstance(worst, float):
                return add_zero(worst)
        except ValueError as e:
            return ""
        return worst

    def update_stats():
        ao5 = calculate_average(len(times), 5)
        ao5s.append(ao5)
        ao5_image.chars = char(f'AO5: {ao5}')
        ao12 = calculate_average(len(times), 12)
        ao12s.append(ao12)
        ao12_image.chars = char(f'AO12: {ao12}')
        best_ao5 = get_best_average(5)
        best_ao5_image.chars = char(f'Best AO5: {best_ao5}')
        best_ao12 = get_best_average(12)
        best_ao12_image.chars = char(f'Best AO12: {best_ao12}')
        best_time = get_best_time()
        best_time_image.chars = char(f'Best time: {best_time}')
        worst_time = get_worst_time()
        worst_time_image.chars = char(f'Worst time: {worst_time}')

        len_successes = 0
        for t in times:
            if not ((isinstance(t, str)) and (t[:3] == 'DNF')):
                len_successes += 1

        number_of_times_image.chars = char(f'Number of Times: {len_successes}/{len(times)}')
        session_mean = get_session_mean()
        session_mean_image.chars = char(f'Session Mean: {session_mean}')

        return ao5, ao12
                
    session_name_image = Image(canvas, 0, 0, char(session.string))
    scramble_image = Scramble(canvas, 0, 2, char(
        generate_scramble(int(settings['puzzle']),
        int(settings['scramble-length']))))
    scramble_image.render()

    number_display = NumberDisplay(canvas, 15, 7)
    timer_background = Image(canvas, 0, 5, char(TIMER_BACKGROUND))

    ao5_image = CoverUpImage(canvas, 51, 6, char(f'AO5: {calculate_average(len(times), 5)}'))
    ao12_image = CoverUpImage(canvas, 51, 7, char(f'AO12: {calculate_average(len(times), 12)}'))
    best_ao5_image = CoverUpImage(canvas, 51, 8, char(f'Best AO5: {get_best_average(5)}'))
    best_ao12_image = CoverUpImage(canvas, 51, 9, char(f'Best AO12: {get_best_average(12)}'))
    best_time_image = CoverUpImage(canvas, 51, 10, char(f'Best time: {get_best_time()}'))
    worst_time_image = CoverUpImage(canvas, 51, 11, char(f'Worst time: {get_worst_time()}'))

    len_successes = 0
    for t in times:
        if not ((isinstance(t, str)) and (t[:3] == 'DNF')):
            len_successes += 1
    number_of_times_image = CoverUpImage(canvas, 51, 12, char(f'Number of Times: {len_successes}/{len(times)}'))
    
    session_mean_image = CoverUpImage(canvas, 51, 13, char(f'Session Mean: {get_session_mean()}'))

    if isfile(f'{HOME}/.cl-timer_rc'):
        with open(f'{HOME}/.cl-timer_rc', 'r') as f:
            rc_commands = f.read().strip().split('\n')
            rc_commands.remove('')
        for command in rc_commands:
            try:
                command_line(canvas, stdscr, settings, scramble_image, settings_file, session_file, times, ao5s, ao12s,
                            scrambles, session, session_name_image, update_stats, add_time, calculate_average, aliases,
                            True, command)
            except CommandSyntaxError:
                pass
    else:
        with open(f'{HOME}/.cl-timer_rc', 'w+') as f:
            pass
    
    ao5_image.render()
    ao12_image.render()
    best_ao5_image.render()
    best_ao12_image.render()
    best_time_image.render()
    worst_time_image.render()
    number_of_times_image.render()
    session_mean_image.render()

    timer_running = False
    delay = 0  # how far behind the program is
    spacebar_pressed = False
    last_25_keys = [-1 for _ in range(25)]

    solve_start_time = 0
    frame = 0
    while True:

        # to make sure each frame is exactly 0.01 secs
        start_time = time.time()

        key = stdscr.getch()

        if key == 58:  # :
            try:
                command_line(canvas, stdscr, settings, scramble_image,
                             settings_file, session_file, times, ao5s,
                             ao12s, scrambles, session, session_name_image,
                             update_stats, add_time, calculate_average, aliases)
            except CommandSyntaxError:
                pass
            continue

        if not timer_running:
            if key == 32:
                solve_start_time = time.time()
        last_25_keys.append(key)
        last_25_keys.pop(0)

        if not timer_running:

            if spacebar_pressed:
                if 32 in last_25_keys:
                    time.sleep(0.01)
                    continue
                else:
                    spacebar_pressed = False

                    timer_running = True
                    number_display.reset()

            else:
                if key == 32:  # spacebar
                    spacebar_pressed = True

        else:
            if key == 32:
                frame = 0
                timer_running = False

                t = round(time.time() - solve_start_time, 2)

                add_time(t)
                

        session_name_image.render()
        
        timer_background.render()
        number_display.render()

        stdscr.clear()
        stdscr.addstr(canvas.display)
        stdscr.refresh()

        if timer_running:
            number_display.time = time.time() - solve_start_time
            number_display.update()

        # take away from sleep time the amount that will get us back on track
        duration = time.time() - start_time
        if (duration + delay) > 0.01:
            # can't make it back to on-time right now
            # by not sleeping, we have saved (0.01 - duration) seconds
            delay -= 0.01 - duration
        else:
            time.sleep(0.01 - (duration + delay))
        
        frame += 1

def main():
    try:
        curses.wrapper(mainloops)
    except ExitException:
        subprocess.call(['clear'])

if __name__ == '__main__':
    main()